// Copyright Â© 2024 KubeStack-AI Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package analysis

import (
	"github.com/kubestack-ai/kubestack-ai/internal/common/types/enum"
	"github.com/kubestack-ai/kubestack-ai/internal/core/models"
)

// AIInput represents the structured input sent to an AI/LLM for analysis.
// This schema defines the contract between the orchestrator and the AI analyzer.
type AIInput struct {
	// Context provides environmental and operational context for the analysis.
	Context AIContext `json:"context"`

	// Data contains the collected plugin data to be analyzed.
	Data CollectedDataView `json:"data"`
}

// AIContext provides contextual information about the environment and user intent.
// This helps the AI understand the operational context and provide more relevant analysis.
type AIContext struct {
	// Middleware is the type of middleware being analyzed (e.g., "redis", "mysql").
	Middleware string `json:"middleware"`

	// Namespace is the Kubernetes namespace (if applicable).
	Namespace string `json:"namespace,omitempty"`

	// Instance is the specific instance name being analyzed.
	Instance string `json:"instance"`

	// Environment describes the deployment environment (e.g., "production", "staging").
	Environment string `json:"environment,omitempty"`

	// UserIntent describes the user's goal or concern (if provided).
	UserIntent string `json:"userIntent,omitempty"`

	// Timestamp indicates when the data was collected (ISO 8601 format).
	Timestamp string `json:"timestamp"`
}

// CollectedDataView is a JSON-serializable view of the collected plugin data.
// It transforms internal data structures into a format suitable for AI consumption.
type CollectedDataView struct {
	// Metrics contains performance and operational metrics.
	Metrics map[string]interface{} `json:"metrics,omitempty"`

	// Logs contains recent log entries (limited to most recent/relevant).
	Logs []string `json:"logs,omitempty"`

	// Config contains configuration key-value pairs.
	Config map[string]string `json:"config,omitempty"`

	// Additional metadata or custom fields.
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// AIOutput represents the structured output from an AI/LLM analysis.
// This schema defines the contract for AI analysis results that will be
// converted into the standard AnalysisResult format.
type AIOutput struct {
	// Summary is a high-level overview of the analysis findings.
	Summary string `json:"summary"`

	// Reasoning provides the chain-of-thought or rationale behind the analysis.
	// This is optional but helps with transparency and debugging.
	Reasoning string `json:"reasoning,omitempty"`

	// Issues is the list of identified problems or anomalies.
	Issues []AIIssue `json:"issues"`
}

// AIIssue represents a single issue identified by the AI.
// It mirrors the models.Issue structure but is optimized for JSON serialization.
type AIIssue struct {
	// ID is a unique identifier for this issue (should be generated by AI or analyzer).
	ID string `json:"id"`

	// Title is a concise, human-readable title for the issue.
	Title string `json:"title"`

	// Severity indicates the seriousness of the issue (Critical, High, Medium, Low, Info).
	Severity string `json:"severity"`

	// Description provides a detailed explanation of the issue.
	Description string `json:"description"`

	// Evidence provides concrete data supporting the finding.
	Evidence string `json:"evidence"`

	// Recommendations contains suggested actions to resolve the issue.
	Recommendations []AIRecommendation `json:"recommendations,omitempty"`
}

// AIRecommendation represents a suggested action to resolve an issue.
type AIRecommendation struct {
	// ID is a unique identifier for this recommendation.
	ID string `json:"id"`

	// Description is a human-readable explanation of the recommended action.
	Description string `json:"description"`

	// CanAutoFix indicates whether this recommendation can be automatically applied.
	CanAutoFix bool `json:"canAutoFix"`

	// Priority indicates the importance of this recommendation (0=Low, 1=Medium, 2=High).
	Priority int `json:"priority"`

	// Fix contains the detailed action to be performed (optional).
	Fix *AIFixAction `json:"fix,omitempty"`
}

// AIFixAction represents a concrete fix action.
type AIFixAction struct {
	// ID is a unique identifier for this fix action.
	ID string `json:"id"`

	// Description is a human-readable explanation of what the fix does.
	Description string `json:"description"`

	// Command is the shell command to be executed.
	Command string `json:"command,omitempty"`

	// RollbackCommand is the command to undo the action.
	RollbackCommand string `json:"rollbackCommand,omitempty"`

	// Parameters provides additional parameters for the fix.
	Parameters map[string]string `json:"parameters,omitempty"`

	// Category classifies the action type (e.g., "ConfigChange", "Restart").
	Category string `json:"category,omitempty"`
}

// BuildAIInput constructs an AIInput from CollectedData and context information.
func BuildAIInput(data *models.CollectedData, middleware, namespace, instance string) *AIInput {
	input := &AIInput{
		Context: AIContext{
			Middleware: middleware,
			Namespace:  namespace,
			Instance:   instance,
			Timestamp:  getCurrentTimestamp(),
		},
		Data: CollectedDataView{
			Metrics:  make(map[string]interface{}),
			Logs:     make([]string, 0),
			Config:   make(map[string]string),
			Metadata: make(map[string]interface{}),
		},
	}

	// Transform metrics data
	if data.Metrics != nil && data.Metrics.Data != nil {
		input.Data.Metrics = data.Metrics.Data
	}

	// Transform logs data (limit to recent entries for token efficiency)
	if data.Logs != nil && data.Logs.Entries != nil {
		maxLogs := 50
		if len(data.Logs.Entries) > maxLogs {
			input.Data.Logs = data.Logs.Entries[len(data.Logs.Entries)-maxLogs:]
		} else {
			input.Data.Logs = data.Logs.Entries
		}
	}

	// Transform config data
	if data.Config != nil && data.Config.Data != nil {
		input.Data.Config = data.Config.Data
	}

	return input
}

// ConvertToModelIssues converts AIOutput issues to models.Issue format.
func (output *AIOutput) ConvertToModelIssues() []*models.Issue {
	issues := make([]*models.Issue, 0, len(output.Issues))

	for _, aiIssue := range output.Issues {
		issue := &models.Issue{
			ID:          aiIssue.ID,
			Source:      "AI",
			Title:       aiIssue.Title,
			Severity:    parseSeverity(aiIssue.Severity),
			Description: aiIssue.Description,
			Evidence:    aiIssue.Evidence,
		}

		// Convert recommendations
		if len(aiIssue.Recommendations) > 0 {
			issue.Recommendations = make([]*models.Recommendation, 0, len(aiIssue.Recommendations))
			for _, aiRec := range aiIssue.Recommendations {
				rec := &models.Recommendation{
					ID:          aiRec.ID,
					Description: aiRec.Description,
					CanAutoFix:  aiRec.CanAutoFix,
					Priority:    models.Priority(aiRec.Priority),
				}

				// Convert fix action if present
				if aiRec.Fix != nil {
					rec.Fix = models.FixAction{
						ID:              aiRec.Fix.ID,
						Description:     aiRec.Fix.Description,
						Command:         aiRec.Fix.Command,
						RollbackCommand: aiRec.Fix.RollbackCommand,
						Parameters:      aiRec.Fix.Parameters,
						Category:        aiRec.Fix.Category,
					}
				}

				issue.Recommendations = append(issue.Recommendations, rec)
			}
		}

		issues = append(issues, issue)
	}

	return issues
}

// getCurrentTimestamp returns the current timestamp in ISO 8601 format.
func getCurrentTimestamp() string {
	// This is a placeholder - in real implementation, use time.Now().Format(time.RFC3339)
	return "2024-01-01T00:00:00Z"
}

// parseSeverity converts a severity string to the enum.SeverityLevel type.
func parseSeverity(severity string) enum.SeverityLevel {
	// Map common severity levels to standard enum values
	switch severity {
	case "Critical", "critical", "CRITICAL":
		return enum.SeverityCritical
	case "High", "high", "HIGH":
		return enum.SeverityHigh
	case "Medium", "medium", "MEDIUM":
		return enum.SeverityMedium
	case "Low", "low", "LOW":
		return enum.SeverityLow
	case "Info", "info", "INFO":
		return enum.SeverityInfo
	case "Warning", "warning", "WARNING":
		return enum.SeverityWarning
	default:
		return enum.SeverityMedium // Default to Medium if unknown
	}
}
